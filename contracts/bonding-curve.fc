;; BondingCurveContract
;; Core bonding curve with square root pricing

#include "imports/stdlib.fc";

;; Constants
const int BASE_PRICE = 1000; ;; 0.000001 TON (in nanotons)
const int MAX_BUY_PERCENT = 2; ;; 2% of remaining
const int MAX_BUY_ABSOLUTE = 50000000 * 1000000000; ;; 50M tokens
const int PLATFORM_FEE_PERCENT = 5;
const int CREATOR_FEE_PERCENT = 5;
const int RESERVE_PERCENT = 50;
const int LIQUIDITY_PERCENT = 40;
const int SELL_FEE_PERCENT = 1;

;; Error codes
const int ERROR_ALREADY_GRADUATED = 400;
const int ERROR_ALREADY_FAILED = 401;
const int ERROR_MIN_BUY_NOT_MET = 402;
const int ERROR_DEADLINE_PASSED = 403;
const int ERROR_MAX_BUY_EXCEEDED = 404;
const int ERROR_SELL_GRADUATED = 410;
const int ERROR_SELL_FAILED = 411;
const int ERROR_INSUFFICIENT_RESERVE = 412;
const int ERROR_NOT_FAILED = 420;
const int ERROR_NO_REFUND = 421;

;; Storage structure (matches data-model.md)
global int ctx_tokens_sold;
global int ctx_reserve_balance;
global int ctx_total_raised;
global int ctx_is_graduated;
global int ctx_is_failed;
global int ctx_soft_cap_reached;
global int ctx_soft_cap_timestamp;
global int ctx_liquidity_accumulated;

() load_data() impure {
    slice ds = get_data().begin_parse();

    slice jetton_minter = ds~load_msg_addr();
    slice creator = ds~load_msg_addr();
    int launch_timestamp = ds~load_uint(32);
    int hard_cap = ds~load_coins();
    int soft_cap = ds~load_coins();
    int time_limit = ds~load_uint(32);
    int total_supply = ds~load_coins();

    ctx_tokens_sold = ds~load_coins();
    ctx_reserve_balance = ds~load_coins();
    ctx_total_raised = ds~load_coins();
    ctx_is_graduated = ds~load_uint(1);
    ctx_is_failed = ds~load_uint(1);
    ctx_soft_cap_reached = ds~load_uint(1);
    ctx_soft_cap_timestamp = ds~load_uint(32);

    slice dex_pool = ds~load_msg_addr();
    ctx_liquidity_accumulated = ds~load_coins();

    cell buyer_contributions = ds~load_ref();
    cell refund_claims = ds~load_ref();
}

() save_data() impure {
    ;; Simplified save - only updates frequently changing fields
    ;; Full implementation would reconstruct entire storage cell
}

;; Newton's method for integer square root
int sqrt_newton(int x) inline {
    if (x == 0) {
        return 0;
    }

    int z = (x + 1) / 2;
    int y = x;
    int iterations = 0;

    while ((z < y) & (iterations < 20)) {
        y = z;
        z = (x / z + z) / 2;
        iterations += 1;
    }

    return y;
}

;; Calculate price at k tokens sold: Price(k) = base_price × √(k / total_supply)
int calculate_price(int k, int total_supply) inline {
    if (k == 0) {
        return BASE_PRICE;
    }

    ;; price = BASE_PRICE * sqrt(k / total_supply)
    ;; = BASE_PRICE * sqrt(k) / sqrt(total_supply)

    int sqrt_k = sqrt_newton(k);
    int sqrt_total = sqrt_newton(total_supply);

    return (BASE_PRICE * sqrt_k) / sqrt_total;
}

;; Calculate cost for buying tokens: ∫ Price(k) dk from k to k+amount
int calculate_buy_cost(int current_k, int token_amount, int total_supply) inline {
    ;; Integral of sqrt(k) from k1 to k2 = (2/3) * (k2^(3/2) - k1^(3/2))
    ;; Cost = BASE_PRICE * (2/3) * (sqrt(k2^3) - sqrt(k1^3)) / sqrt(total_supply)

    int k1 = current_k;
    int k2 = current_k + token_amount;

    ;; k^(3/2) = k * sqrt(k)
    int k1_32 = k1 * sqrt_newton(k1);
    int k2_32 = k2 * sqrt_newton(k2);

    int diff = k2_32 - k1_32;
    int sqrt_total = sqrt_newton(total_supply);

    ;; Multiply by 2/3 = * 2 / 3
    int cost = (BASE_PRICE * 2 * diff) / (3 * sqrt_total);

    return cost;
}

;; Calculate tokens received for TON amount (inverse of buy_cost)
int calculate_tokens_for_ton(int ton_amount, int current_k, int total_supply) inline {
    ;; Simplified binary search approach for hackathon
    ;; Production would use more precise inverse calculation

    int low = 0;
    int high = total_supply - current_k;
    int result = 0;

    repeat(20) { ;; 20 iterations for binary search
        int mid = (low + high) / 2;
        int cost = calculate_buy_cost(current_k, mid, total_supply);

        if (cost <= ton_amount) {
            result = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return result;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    load_data();

    ;; Buy operation (0x01)
    if (op == 0x01) {
        throw_if(ERROR_ALREADY_GRADUATED, ctx_is_graduated);
        throw_if(ERROR_ALREADY_FAILED, ctx_is_failed);

        ;; Calculate tokens for buy amount
        ;; Simplified implementation for hackathon
        ;; Production would include all validations from spec

        int buy_amount = msg_value - 50000000; ;; Reserve 0.05 TON for gas
        int tokens = buy_amount / BASE_PRICE; ;; Simplified linear for hackathon

        ;; Split funds (50/40/5/5)
        int reserve_add = (buy_amount * RESERVE_PERCENT) / 100;
        int liquidity_add = (buy_amount * LIQUIDITY_PERCENT) / 100;
        int creator_fee = (buy_amount * CREATOR_FEE_PERCENT) / 100;
        int platform_fee = (buy_amount * PLATFORM_FEE_PERCENT) / 100;

        ctx_reserve_balance += reserve_add;
        ctx_liquidity_accumulated += liquidity_add;
        ctx_total_raised += buy_amount;
        ctx_tokens_sold += tokens;

        ;; Check soft cap
        ;; Placeholder - full implementation would check and update flags

        ;; Check hard cap and graduate
        ;; Placeholder - full implementation would trigger graduation

        save_data();

        ;; Mint tokens to buyer
        ;; Placeholder - send message to jetton_minter

        return ();
    }

    ;; Sell operation (0x02)
    if (op == 0x02) {
        throw_if(ERROR_SELL_GRADUATED, ctx_is_graduated);
        throw_if(ERROR_SELL_FAILED, ctx_is_failed);

        int token_amount = in_msg_body~load_coins();

        ;; Calculate return amount
        ;; Simplified implementation for hackathon
        int return_amount = (token_amount * BASE_PRICE * 99) / 100; ;; 1% fee

        throw_if(ERROR_INSUFFICIENT_RESERVE, ctx_reserve_balance < return_amount);

        ctx_reserve_balance -= return_amount;
        ctx_tokens_sold -= token_amount;

        save_data();

        ;; Send TON back to seller
        ;; Burn tokens
        ;; Placeholder - full implementation

        return ();
    }

    ;; Claim refund (0x03)
    if (op == 0x03) {
        throw_unless(ERROR_NOT_FAILED, ctx_is_failed);

        ;; Look up refund amount for sender
        ;; Placeholder - full implementation would use refund_claims dictionary

        ;; Transfer refund
        ;; Burn tokens
        ;; Remove from refund_claims

        return ();
    }

    ;; Trigger failure check (0x04)
    if (op == 0x04) {
        ;; Check if deadline passed and soft cap not reached
        ;; Placeholder - full implementation

        return ();
    }

    throw(0xffff);
}

;; Get methods

(int, int, int, int, int, int, int) get_launch_stats() method_id {
    load_data();
    return (
        ctx_total_raised,
        ctx_tokens_sold,
        ctx_reserve_balance,
        ctx_liquidity_accumulated,
        ctx_is_graduated,
        ctx_is_failed,
        ctx_soft_cap_reached
    );
}

int get_buy_quote(int ton_amount) method_id {
    load_data();
    ;; Placeholder - return token amount for TON
    return ton_amount / BASE_PRICE;
}

int get_sell_quote(int token_amount) method_id {
    load_data();
    return (token_amount * BASE_PRICE * 99) / 100;
}

int calculate_current_price() method_id {
    load_data();
    ;; Placeholder - return current price
    return BASE_PRICE;
}

int get_user_refund(slice user_address) method_id {
    load_data();
    ;; Placeholder - look up in refund_claims
    return 0;
}
